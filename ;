use crate::errors::config_errors::{CompactionConfigError, CompactionConfigErrors};

#[derive(Debug)]
pub enum CompactionStrategy {
    Leveled,
    Tiered,
    Hybrid,
}

#[derive(Debug)]
pub struct CompactionConfig {
    compaction_strategy: CompactionStrategy,
    level_size_muliplier: u8,
    max_levels: u8,
    l0_file_count_compaction_trigger: u8,
    max_bytes_for_level_base: u64,
    target_file_size_base: u64,
}

const DEFAULT_LEVEL_SIZE_MULITPLIER: u8 = 10;
const DEFAULT_MAX_LEVELS: u8 = 7;
const DEFAULT_LEVEL_0_FILE_COUNT_COMPACTION_TRIGGER: u8 = 10;
const DEFAULT_MAX_BYTES_FOR_LEVEL_BASE: u64 = 512 * 1024 * 1024;
const DEFAULT_TARGET_FILE_SIZE_BASE: u64 = 64 * 1024 * 1024;

impl Default for CompactionConfig {
    fn default() -> Self {
        CompactionConfig {
            compaction_strategy: CompactionStrategy::Leveled,
            level_size_muliplier: DEFAULT_LEVEL_SIZE_MULITPLIER,
            max_levels: DEFAULT_MAX_LEVELS,
            l0_file_count_compaction_trigger: DEFAULT_LEVEL_0_FILE_COUNT_COMPACTION_TRIGGER,
            max_bytes_for_level_base: DEFAULT_MAX_BYTES_FOR_LEVEL_BASE,
            target_file_size_base: DEFAULT_TARGET_FILE_SIZE_BASE,
        }
    }
}

impl CompactionConfig {
    pub fn validate(&self) -> Result<(), CompactionConfigErrors> {
        let mut cce = CompactionConfigErrors::new();
        if self.level_size_muliplier < 2 {
            cce.errors
                .push(CompactionConfigError::LevelSizeMultiplierTooLow(
                    self.level_size_muliplier,
                ));
        }

        if self.max_levels < 3 {
            cce.errors
                .push(CompactionConfigError::MaxLevelTooSmall(self.max_levels));
        }
        if self.max_levels > 10 {
            cce.errors
                .push(CompactionConfigError::MaxLevelTooBig(self.max_levels));
        }

        if self.l0_file_count_compaction_trigger < 2 {
            cce.errors.push(CompactionConfigError::L0NotEnoughFiles(
                self.l0_file_count_compaction_trigger,
            ));
        }

        if self.target_file_size_base < 1024 * 1024 {
            cce.errors.push(CompactionConfigError::TargetFileSizeTooLow(
                self.target_file_size_base,
            ));
        }

        if !self
            .max_bytes_for_level_base
            .is_multiple_of(self.target_file_size_base)
            || self.max_bytes_for_level_base <= self.target_file_size_base
        {
            cce.errors
                .push(CompactionConfigError::MaxBytesTargetSizeMismatch);
        }

        if cce.errors.is_empty() {
            Ok(())
        }

        cce
    }
}
